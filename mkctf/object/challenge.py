'''
file: challenge.py
date: 2018-02-27
author: paul.dautry
purpose:

'''
# =============================================================================
#  IMPORTS
# =============================================================================
from os import urandom
from stat import S_IRWXU
from asyncio import create_subprocess_exec, wait_for, TimeoutError
from subprocess import PIPE, CalledProcessError
from mkctf.helper.log import app_log
from mkctf.object.configurable import Configurable
# =============================================================================
#  CLASSES
# =============================================================================
class Challenge(Configurable):
    '''[summary]
    '''
    @staticmethod
    def make_flag(repo_conf, size=32):
        '''Makes a flag
        '''
        prefix = repo_conf['flag']['prefix']
        content = urandom(size).hex()
        suffix = repo_conf['flag']['suffix']
        return f"{prefix}{content}{suffix}"

    def __init__(self, chall_conf_path, repo_conf):
        '''Constructs a new instance
        '''
        super().__init__(chall_conf_path)
        self.repo_conf = repo_conf

    def __create_dir(self, directory):
        '''Creates a directory
        '''
        dir_path = self.working_dir().joinpath(directory)

        if not dir_path.is_dir():
            dir_path.mkdir(parents=True, exist_ok=True)

            return True

        return False

    def __create_file(self, filename, executable=False):
        '''Creates a file
        '''
        filepath = self.working_dir().joinpath(filename)

        filepath.parent.mkdir(parents=True, exist_ok=True)

        if not filepath.is_file():
            with filepath.open('w') as f:
                if executable:
                    f.write('#!/usr/bin/env bash\n')

                f.write('# file automatically generated by mkctf.\n')

                if executable:
                    f.write('>&2 echo "not implemented."\n')
                    f.write('exit 4\n')

            if executable:
                filepath.chmod(S_IRWXU)

            return True

        return False

    async def __run(self, script, timeout):
        '''Runs a script as an asynchronous subprocess
        '''
        if not script.startswith('/'):
            script = f'./{script}'

        proc = await create_subprocess_exec(script,
                                            stdout=PIPE,
                                            stderr=PIPE,
                                            cwd=str(self.working_dir()))

        try:
            stdout, stderr = await wait_for(proc.communicate(), timeout=timeout)
        except TimeoutError as e:
            proc.terminate()
            return (None, None, None)
        except CalledProcessError as e:
            proc.terminate()
            return (e.returncode, e.stdout, e.stderr)

        return (proc.returncode, stdout, stderr)

    @property
    def slug(self):
        '''Gets challenge's slug
        '''
        return self.working_dir().name

    @property
    def tags(self):
        '''Gets challenge's category
        '''
        return self.get_conf('tags')

    @property
    def is_standalone(self):
        '''Determines if challenge is static
        '''
        return self.get_conf('standalone')

    @property
    def enabled(self):
        '''Determines if challenge is enabled
        '''
        return self.get_conf('enabled')

    def enable(self, enabled=True):
        '''Enables or disables the challenge
        '''
        conf = self.get_conf()
        conf['enabled'] = enabled
        self.set_conf(conf)

    def renew_flag(self, size=32):
        '''Renews challenge's flag
        '''
        conf = self.get_conf()
        conf['flag'] = Challenge.make_flag(self.repo_conf, size)
        self.set_conf(conf)
        return conf['flag']

    def create(self):
        '''Creates challenge files
        '''
        self.working_dir().mkdir(parents=True, exist_ok=True)

        directories = self.repo_conf['directories']['public'][::]
        directories += self.repo_conf['directories']['private']

        for directory in directories:
            if not self.__create_dir(directory):
                app_log.warning(f"directory exists already: {directory}")

        for file in self.repo_conf['files']['txt']:
            if not self.__create_file(file):
                app_log.warning(f"file exists already: {file}")

        bin_files = [
            self.repo_conf['files']['build'],
            self.repo_conf['files']['deploy'],
            self.repo_conf['files']['status']
        ]

        for file in bin_files:
            if not self.__create_file(file, executable=True):
                app_log.warning(f"file exists already: {file}")

        return True

    def exportable(self):
        '''Yields files contained in public folders
        '''
        wd = self.working_dir()
        for directory in self.repo_conf['directories']['public']:
            dir_path = wd.joinpath(directory)
            for de in self._scandirs(dir_path):
                yield de

    async def build(self, timeout=4):
        '''Builds the challenge
        '''
        return await self.__run(self.repo_conf['files']['build'], timeout)

    async def deploy(self, timeout=4):
        '''Deploys the challenge
        '''
        return await self.__run(self.repo_conf['files']['deploy'], timeout)

    async def status(self, timeout=4):
        '''Queries the status of a deployed challenge
        '''
        return await self.__run(self.repo_conf['files']['status'], timeout)


